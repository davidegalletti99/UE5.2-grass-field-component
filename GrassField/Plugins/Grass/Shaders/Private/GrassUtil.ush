#pragma once
// #include "Noise.ush"

#define GRAVITATIONAL_ACCELERATION 9.81
#define PI 3.14159265359
#define SQ_2PI 2.50662827463

// Calcola la curva di Bézier quadratica
#define quadBez(p0, p1, p2, t) (lerp(p0, lerp(p1, p2, t), t))
#define invTanMap(x) (2 * atan(x) / PI)
#define gaussianMap(m, s, x) (exp(-(x - m)*(x - m) / (2 * s * s)) / (s * SQ_2PI))

/** 
 * Struct per la generazione dei fili d'erba
 */
struct GrassData
{
    float3 Position;
    float2 Facing;
	// float WindStrength;
    
    int Hash;
    
    float Height;
    float Width;
    
    // float Tilt;
    // float Bend;
};

struct PackedGrassData
{
    float3 Position;
    uint Facing;
	// float WindStrength;

    int Hash;

    uint HeightAndWidth;
	// uint TiltAndBand;
};

struct LodGrassData
{
    float3 Position;
    float2 Facing;
	// float WindStrength;
    
    int Hash;
    uint LodLevel;
    
    float Height;
    float Width;
    
    // float Tilt;
    // float Bend;
};

struct PackedLodGrassData
{
    float3 Position;
    uint Facing;
	// float WindStrength;

    int Hash;
    uint LodLevel;

    uint HeightAndWidth;
	// uint TiltAndBand;
};


PackedGrassData Pack(GrassData InData)
{
    PackedGrassData OutData = (PackedGrassData) 0;
    
    // prendo i 4 bit medno significativi dall'esponente e 12 dalla mantissa
    // 0    7    f    f    f    8    0    0
    // 0000 0111 1111 1111 1111 1000 0000 0000
    OutData.HeightAndWidth = (asuint(InData.Height) & 0x7fff8000) << 1;
    OutData.HeightAndWidth |= (asuint(InData.Width) & 0x7fff8000) >> 15;
    
    // prendo i 3 bit medno significativi dall'esponente e 13 dalla mantissa    
    // 0    3    f    f    f    a    0    0
    // 0000 0011 1111 1111 1111 1100 0000 0000
    uint Signes = (asuint(InData.Facing.x) & 0x80000000);
    Signes |= (asuint(InData.Facing.y) & 0x80000000) >> 16;
    
    OutData.Facing = (asuint(InData.Facing.x) & 0x3fff8000) << 1;
    OutData.Facing |= (asuint(InData.Facing.y) & 0x3fff8000) >> 15;
    OutData.Facing |= Signes;

    OutData.Position = InData.Position;
    OutData.Hash = InData.Hash;
    
    return OutData;
}

GrassData Unpack(PackedGrassData InData)
{
    GrassData OutData = (GrassData) 0;
    
    OutData.Position = InData.Position;
    OutData.Hash = InData.Hash;
    
    OutData.Height = asfloat((InData.HeightAndWidth & 0xffff0000) >> 1);
    OutData.Width = asfloat((InData.HeightAndWidth & 0x0000ffff) << 15);
    
    uint SignX = InData.Facing & 0x80000000;
    uint SignY = (InData.Facing & 0x00008000) << 16;
    OutData.Facing.x = asfloat(SignX | (InData.Facing & 0x7fff0000) >> 1);
    OutData.Facing.y = asfloat(SignY | (InData.Facing & 0x00007fff) << 15);
    
    return OutData;
}

LodGrassData Unpack(PackedLodGrassData InData)
{
    LodGrassData OutData = (LodGrassData) 0;
    
    OutData.Position = InData.Position;
    
    OutData.Hash = InData.Hash;
    OutData.LodLevel = InData.LodLevel;
    
    OutData.Height = asfloat((InData.HeightAndWidth & 0xffff0000) >> 1);
    OutData.Width = asfloat((InData.HeightAndWidth & 0x0000ffff) << 15);
    
    uint SignX = InData.Facing & 0x80000000;
    uint SignY = (InData.Facing & 0x00008000) << 16;
    OutData.Facing.x = asfloat(SignX | (InData.Facing & 0x7fff0000) >> 1);
    OutData.Facing.y = asfloat(SignY | (InData.Facing & 0x00007fff) << 15);
    
    return OutData;
}
    

struct GrassVertex
{
    float3 Position;
    float2 UV;
    float3 Normal;
};

struct GrassInstance
{
    float3 Position;
    float Offset; // Animation Offset
};

/** Return false if the AABB is completely outside one of the planes. */
bool PlaneTestAABB(in float4 InPlanes[5], in float3 InCenter, in float3 InExtent)
{
    bool bPlaneTest = true;
	
	[unroll]
    for (uint PlaneIndex = 0; PlaneIndex < 5; ++PlaneIndex)
    {
        float3 PlaneSigns;
        PlaneSigns.x = InPlanes[PlaneIndex].x >= 0.f ? 1.f : -1.f;
        PlaneSigns.y = InPlanes[PlaneIndex].y >= 0.f ? 1.f : -1.f;
        PlaneSigns.z = InPlanes[PlaneIndex].z >= 0.f ? 1.f : -1.f;

        bool bInsidePlane = dot(InPlanes[PlaneIndex], float4(InCenter + InExtent * PlaneSigns, 1.0f)) > 0.f;
        bPlaneTest = bPlaneTest && bInsidePlane;
    }

    return bPlaneTest;
}

bool IsInViewFrustum(in float3 position, in float4x4 ViewProjectionMatrix, in float margin)
{
    float4 position4 = float4(position, 1.0f);
    float4 viewspace = mul(position4, ViewProjectionMatrix);
    
    float3 clipspace = viewspace.xyz;
    clipspace /= viewspace.w;

    clipspace.xy = clipspace.xy / 2.0f + 0.5f;
    
    return clipspace.x >= 0.0f - margin && clipspace.x <= 1.0f + margin
        && clipspace.y >= 0.0f - margin && clipspace.y <= 1.0f + margin
        && clipspace.z >= 0.0f && clipspace.z <= 1.0f;
}

/**
 * Aggiunge il vertice @data al buffer @VertexBuffer 
 * in posizione @vertexPos
 */ 
void addPoint(
    in RWStructuredBuffer<GrassVertex> VertexBuffer,
    in uint vertexPos, in GrassVertex data)
{
    VertexBuffer[vertexPos] = data;
}

/**
 * Aggiunge il triangolo definiito dagli indici @idx1, @idx2 e @idx3 
 * al buffer @IndexBuffer partendo dalla posizione @indexPos
 */
void addTri(
    in RWStructuredBuffer<uint> IndexBuffer, 
    in uint indexPos, in uint idx1, in uint idx2, in uint idx3)
{
    IndexBuffer[indexPos + 0] = idx1;
    IndexBuffer[indexPos + 1] = idx2;
    IndexBuffer[indexPos + 2] = idx3;
}

//  z
//  |
//  |
//  |         * *         -
//  |    y  *     *       |
//  |   /  *              | height
//  |  /  *               |
//  | /  *                |
//  |/   *                -
//  +-------------------------- x
//  0
float3 computeInitialVelocity(in float3 seed, in float height)
{
    float3 v0 = seed;
    v0.xy += sign(v0.xy) * 1.5;
    v0.z = sqrt(2 * GRAVITATIONAL_ACCELERATION * height);
    return v0;
}

uint computeLodSteps(in uint2 MinMaxLod, float CutoffDistance, in float3 CameraPosition, in float3 PointPosition)
{
    float dist = distance(CameraPosition, PointPosition);
    return ceil(lerp(MinMaxLod.x, MinMaxLod.y, gaussianMap(0, 0.4f, 2 * dist / CutoffDistance)));

}

float3 movePoint(in float3 pi, in float3 vi, in float t)
{
    float3 p = pi + vi * t;
    p.z -= t * t * GRAVITATIONAL_ACCELERATION / 2;
    return p;
}