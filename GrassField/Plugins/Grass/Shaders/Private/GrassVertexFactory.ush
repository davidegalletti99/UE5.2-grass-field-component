// Copyright Epic Games, Inc. All Rights Reserved.

#if defined(__RESHARPER__) || defined(__INTELLISENSE__)
#define USE_INSTANCING 1
#define INSTANCED_STEREO 0
#define MANUAL_VERTEX_FETCH 0
#define NUM_TEX_COORD_INTERPOLATORS 1
#define NUM_MATERIAL_TEXCOORDS_VERTEX 1

#pragma once
#include "/Engine/Private/MaterialTemplate.ush"
#include "/Engine/Public/Platform.ush"
#endif

#include "/Engine/Private/VertexFactoryCommon.ush"
#include "GrassUtils.ush"
#include "Noise.ush"
//#include "Noise.ush"


#if USE_INSTANCING
StructuredBuffer<FGrassInstance> InstanceBuffer;
float3 LodViewOrigin;
#endif

/** Per-vertex inputs. No vertex buffers are bound. */
struct FVertexFactoryInput
{
    float3  Position                            : ATTRIBUTE0;
	float2	UV	                                : ATTRIBUTE1;
    float3 TangentX                             : ATTRIBUTE2;
    float4 TangentZ                             : ATTRIBUTE3; // TangentZ.w contains sign of tangent basis determinant
#if USE_INSTANCING
    uint    InstanceId  : SV_InstanceID;
#endif
    uint    VertexId    : SV_VertexID;
};

/** Cached intermediates that would otherwise have to be computed multiple times. Avoids relying on the compiler to optimize out redundant operations. */
struct FVertexFactoryIntermediates
{
    float3 LocalPos;
    float2 UV;
    
    half3x3 TangentToLocal;
	half3x3 TangentToWorld;
	half TangentToWorldSign;
    
	/** Cached primitive and instance data */
    FSceneDataIntermediates SceneData;

#if USE_INSTANCING
    int Hash;
    float4 InstanceOrigin;
    float4 InstanceTransform1;
    float4 InstanceTransform2;
    float4 InstanceTransform3;
#endif // USE_INSTANCING
};

/** Attributes to interpolate from the vertex shader to the pixel shader. */
struct FVertexFactoryInterpolantsVSToPS
{
    TANGENTTOWORLD_INTERPOLATOR_BLOCK
    
    nointerpolation uint PrimitiveId : PRIMITIVE_ID;
    
#if NUM_TEX_COORD_INTERPOLATORS
    float4 TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2] : TEXCOORD0;
#endif
    
#if INSTANCED_STEREO
    nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

FInstanceSceneData GetInstanceData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.InstanceData;
}

void SetPrimitiveId(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint PrimitiveId)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
	Interpolants.PrimitiveId = PrimitiveId;
#endif
}

void SetTangents(inout FVertexFactoryInterpolantsVSToPS Interpolants, float3 InTangentToWorld0, float3 InTangentToWorld2, float InTangentToWorldSign)
{
    Interpolants.TangentToWorld0 = float4(InTangentToWorld0, 0);
    Interpolants.TangentToWorld2 = float4(InTangentToWorld2, InTangentToWorldSign);
}

float4 GetTangentToWorld2(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return Interpolants.TangentToWorld2;
}

float4 GetTangentToWorld0(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return Interpolants.TangentToWorld0;
}

half3x3 CalcTangentToWorldNoScale(FVertexFactoryIntermediates Intermediates, half3x3 TangentToLocal)
{
    half3x3 LocalToWorld = LWCToFloat3x3(GetInstanceData(Intermediates).LocalToWorld);
    half3 InvScale = GetInstanceData(Intermediates).InvNonUniformScale;
    LocalToWorld[0] *= InvScale.x;
    LocalToWorld[1] *= InvScale.y;
    LocalToWorld[2] *= InvScale.z;
    return mul(TangentToLocal, LocalToWorld); 
}

half3x3 CalcTangentToLocal(FVertexFactoryInput Input, inout float TangentSign)
{
    half3 TangentX = Input.TangentX;
    half4 TangentZ = Input.TangentZ;

    TangentSign = TangentZ.w;

    // derive the binormal by getting the cross product of the normal and tangent
    half3 TangentY = cross(TangentZ.xyz, TangentX) * TangentZ.w;
	
    // Recalculate TangentX off of the other two vectors
    // This corrects quantization error since TangentX was passed in as a quantized vertex input
    // The error shows up most in specular off of a mesh with a smoothed UV seam (normal is smooth, but tangents vary across the seam)
    half3x3 Result;
    Result[0] = cross(TangentY, TangentZ.xyz) * TangentZ.w;
    Result[1] = TangentY;
    Result[2] = TangentZ.xyz;

    return Result;
}

#if USE_INSTANCING

half3x3 GetInstanceToLocal3x3(FVertexFactoryIntermediates Intermediates)
{
    return half3x3( Intermediates.InstanceTransform1.xyz,
                    Intermediates.InstanceTransform2.xyz,
                    Intermediates.InstanceTransform3.xyz);
}

float4x4 GetInstanceTransform(FVertexFactoryIntermediates Intermediates)
{
    return float4x4(
        float4(Intermediates.InstanceTransform1.xyz, 0.0f),
        float4(Intermediates.InstanceTransform2.xyz, 0.0f),
        float4(Intermediates.InstanceTransform3.xyz, 0.0f),
        float4(Intermediates.InstanceOrigin.xyz, 1.0f));
}

float4x4 GetInstancePrevTransform(FVertexFactoryIntermediates Intermediates)
{
    // Assumes instance transform never change, which means per-instance motion will cause TAA and motion blur artifacts.
    return GetInstanceTransform(Intermediates);
}


float GetInstanceRandom(FVertexFactoryIntermediates Intermediates)
{
    return rand1(Intermediates.Hash);
}

float3 GetInstanceOrigin(FVertexFactoryIntermediates Intermediates)
{
    float3 offset = mul(float3(0, 0, 0), GetInstanceToLocal3x3(Intermediates));
    return Intermediates.InstanceOrigin.xyz + offset;
}
#endif	// USE_INSTANCING

half3x3 CalcTangentToWorld(FVertexFactoryIntermediates Intermediates, half3x3 TangentToLocal)
{
#if USE_INSTANCING
    half3x3 InstanceToWorld = mul(GetInstanceToLocal3x3(Intermediates), LWCToFloat3x3(GetInstanceData(Intermediates).LocalToWorld));
    // remove scaling
    InstanceToWorld[0] = normalize(InstanceToWorld[0]);
    InstanceToWorld[1] = normalize(InstanceToWorld[1]);
    InstanceToWorld[2] = normalize(InstanceToWorld[2]);
    half3x3 TangentToWorld = mul(TangentToLocal, InstanceToWorld);
#else
    half3x3 TangentToWorld = CalcTangentToWorldNoScale(Intermediates, TangentToLocal);
#endif	// USE_INSTANCING
    return TangentToWorld;
}


uint GetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return Interpolants.PrimitiveId;
}

/** Get ID in the GPU Scene. */
uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return GetPrimitiveId(Interpolants);
}

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

#if NUM_TEX_COORD_INTERPOLATORS

void SetUV(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint UVIndex, float2 InValue)
{
    FLATTEN

    if (UVIndex % 2)
    {
        Interpolants.TexCoords[UVIndex / 2].zw = InValue;
    }
    else
    {
        Interpolants.TexCoords[UVIndex / 2].xy = InValue;
    }
}

float2 GetUV(FVertexFactoryInterpolantsVSToPS Interpolants, uint UVIndex)
{
    float4 UVVector = Interpolants.TexCoords[UVIndex / 2];
    return UVIndex % 2 ? UVVector.zw : UVVector.xy;
}
#endif


/** Compute the intermediates for a given vertex. */
FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    
    FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    // Position in local space
    Intermediates.LocalPos = Input.Position;
    Intermediates.UV = Input.UV;
    
#if USE_INSTANCING
    const FGrassInstance InstanceData = InstanceBuffer[Input.InstanceId];
    //Intermediates.SceneData.InstanceData.LocalToWorld = MakeLWCMatrix(0, IDENTITY_MATRIX_4X4);
    
    Intermediates.InstanceTransform1 = InstanceData.Transform[0];
    Intermediates.InstanceTransform2 = InstanceData.Transform[1];
    Intermediates.InstanceTransform3 = InstanceData.Transform[2];
    Intermediates.InstanceOrigin = InstanceData.Transform[3];
#endif // USE_INSTANCING
    
    float TangentSign = 1.0;
    Intermediates.TangentToLocal = CalcTangentToLocal(Input, TangentSign);
    Intermediates.TangentToWorld = CalcTangentToWorld(Intermediates, Intermediates.TangentToLocal);
    Intermediates.TangentToWorldSign = TangentSign * GetInstanceData(Intermediates).DeterminantSign;
    
    return Intermediates;
}

// TODO: Capire come modificare per usare l'instancing
/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal)
{
    FMaterialVertexParameters Result = (FMaterialVertexParameters) 0;
    
    Result.WorldPosition = WorldPosition;
    Result.TangentToWorld = Intermediates.TangentToWorld;
    Result.SceneData = Intermediates.SceneData;
    Result.PrimitiveId = Intermediates.SceneData.PrimitiveId;
    
    // Result.PreSkinnedPosition = WorldPosition;
    // Result.PreSkinnedNormal = TangentToLocal[2]; //TangentBias(Input.TangentZ.xyz);

#if USE_INSTANCING
    FPrimitiveSceneData PrimitiveData = GetPrimitiveData(Intermediates);
    
	float4x4 InstanceToLocal = GetInstanceTransform(Intermediates);
	Result.InstanceLocalToWorld = LWCMultiply(InstanceToLocal, PrimitiveData.LocalToWorld);
	Result.InstanceLocalPosition = Intermediates.LocalPos.xyz;
	Result.InstanceId = GetInstanceId(Input.InstanceId);
    
	// Result.PrevFrameLocalToWorld = LWCMultiply(GetInstancePrevTransform(Intermediates), PrimitiveData.PreviousLocalToWorld);

	// Calculate derived world to local
	{
		float3 Scale2;
		Scale2.x = length2(InstanceToLocal[0].xyz);
		Scale2.y = length2(InstanceToLocal[1].xyz);
		Scale2.z = length2(InstanceToLocal[2].xyz);

		float3 InvNonUniformScale = rsqrt(Scale2);

		float4x4 LocalToInstance = InstanceToLocal;
		LocalToInstance[0].xyz	*= Pow2(InvNonUniformScale.x);
		LocalToInstance[1].xyz	*= Pow2(InvNonUniformScale.y);
		LocalToInstance[2].xyz	*= Pow2(InvNonUniformScale.z);
		LocalToInstance[3].xyz	 = 0.0f;
		LocalToInstance			 = transpose(LocalToInstance);
		LocalToInstance[3].xyz	 = mul(float4(-InstanceToLocal[3].xyz, 0.0f), LocalToInstance).xyz;

		Result.InstanceWorldToLocal = LWCMultiply(PrimitiveData.WorldToLocal, LocalToInstance);
	}
#else
    Result.PrevFrameLocalToWorld = GetInstanceData(Intermediates).PrevLocalToWorld;
#endif // USE_INSTANCING
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX
    UNROLL

    for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordinateIndex++)
    {
        Result.TexCoords[CoordinateIndex] = Intermediates.UV;
    }
#endif  //NUM_MATERIAL_TEXCOORDS_VERTEX

    return Result;
}

#if USE_INSTANCING
// We do not use the hit proxy for instanced meshes
float4 VertexFactoryGetInstanceHitProxyId(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return float4(0, 0, 0, 0);
}
#endif // USE_INSTANCING

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NUM_TEX_COORD_INTERPOLATORS
    UNROLL
    for (uint CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
    {
        Result.TexCoords[CoordinateIndex] = GetUV(Interpolants, CoordinateIndex);
    }
#endif // NUM_TEX_COORD_INTERPOLATORS
    
    const half3 TangentToWorld0 = GetTangentToWorld0(Interpolants).xyz;
	const half4 TangentToWorld2 = GetTangentToWorld2(Interpolants);
    
    Result.WorldTangent = TangentToWorld0;
    Result.WorldNormal = TangentToWorld2.xyz;
	Result.UnMirrored = TangentToWorld2.w;

    Result.TwoSidedSign = 1;
    Result.PrimitiveId = GetPrimitiveId(Interpolants);
    
    Result.TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );
    Result.SvPosition = SvPosition;
    return Result;
}

#if USE_INSTANCING
float4 CalcWorldPosition(float4 Position, float4x4 InstanceTransform, FLWCMatrix LocalToWorld)
{
    return TransformLocalToTranslatedWorld(mul(Position, InstanceTransform).xyz, LocalToWorld);
}
#else
float4 CalcWorldPosition(float4 Position, FLWCMatrix LocalToWorld)
{
    return TransformLocalToTranslatedWorld(Position.xyz, LocalToWorld);
}
#endif // USE_INSTANCING
    



/** Get the 3x3 tangent basis vectors for this vertex factory. This vertex factory will calculate the binormal on-the-fly. */
half3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
}

/** Computes the world space position of this vertex. */
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    FLWCMatrix LocalToWorld = GetInstanceData(Intermediates).LocalToWorld;

#if USE_INSTANCING
    return CalcWorldPosition(float4(Intermediates.LocalPos, 1), GetInstanceTransform(Intermediates), LocalToWorld);
#else
    return CalcWorldPosition(float4(Intermediates.LocalPos, 1), LocalToWorld);
#endif	// USE_INSTANCING
}

/** Computes the world space position of this vertex. */
float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

/** Computes the world space position used by vertex lighting for this vertex. */
float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

/** Constructs values that need to be interpolated from the vertex shader to the pixel shader. */
FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	// Initialize the whole struct to 0
	// Really only the last two components of the packed UVs have the opportunity to be uninitialized
    FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS) 0;

#if NUM_TEX_COORD_INTERPOLATORS
    float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
    GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
    GetCustomInterpolators(VertexParameters, CustomizedUVs);

    UNROLL

    for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
    {
        SetUV(Interpolants, CoordinateIndex, CustomizedUVs[CoordinateIndex]);
    }
#endif
    
    SetTangents(Interpolants, Intermediates.TangentToWorld[0], Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
    SetPrimitiveId(Interpolants, Intermediates.SceneData.PrimitiveId);
    
    return Interpolants;
}

/** Computes the world space normal of this vertex. */
float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToWorld[2];
}

/** Computes the world space position of this vertex last frame. */
float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    FLWCMatrix PreviousLocalToWorld = GetInstanceData(Intermediates).PrevLocalToWorld;
    float4 PrevLocalPosition = float4(Intermediates.LocalPos, 1.0f);
#if USE_INSTANCING
    {
		float4x4 InstanceTransform = GetInstancePrevTransform(Intermediates);
		PrevLocalPosition = mul(float4(Intermediates.LocalPos, 1.0f), InstanceTransform);
    }
#endif
    return TransformPreviousLocalPositionToTranslatedWorld(PrevLocalPosition.xyz, PreviousLocalToWorld);
}

/** Get the translated bounding sphere for this primitive. */
float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    FPrimitiveSceneData PrimitiveData = GetPrimitiveData(GetPrimitiveId(Interpolants));
    return float4(LWCToFloat(LWCAdd(PrimitiveData.ObjectWorldPosition, ResolvedView.PreViewTranslation)), PrimitiveData.ObjectRadius);
}


#include "/Engine/Private/VertexFactoryDefaultInterface.ush"