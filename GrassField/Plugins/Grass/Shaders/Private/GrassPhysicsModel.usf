#pragma once
#include "/Engine/Public/Platform.ush"
#include "GrassCommon.ush"
#include "Noise.ush"

// ************************* Input Data *************************
float DeltaTime;
uint GrassDataNumber;
StructuredBuffer<FPackedGrassData> GrassDataBuffer;

// // Wind Parameters
// float SamplingScale;
//
// Texture2D<float4> GrassWindStrengthMap;
// SamplerState GrassWindStrengthSampler;

// Collision Parameters
float FadingFactor;
uint SpheresNumber;
StructuredBuffer<FSphere> SphereBuffer;

// Gravity Parameters
float4 GravityDirection;
// uint PackedGravityDirection;
// float GravityStrength;

// if use custom center of gravity
int bIsCenterOfGravityEnabled;
float4 GravityCenter;
// float3 GravityCenter;
// float GravityCenterStrength;


// ************************* Output Data *************************
RWTexture1D<float4> RWGrassForceMap;


float4 GetWindForce(float3 Position)
{
	// float2 UV = frac(Position.xy / SamplingScale);
	// float4 Force = GrassWindStrengthMap.Sample(GrassWindStrengthSampler, UV);
	const float DirExt = fbm(Position * 0.01f);
	float2 Direction = float2(cos(DirExt), sin(DirExt));
	float Intensity = noise(Direction);
	float4 Force = float4(Direction, 0, Intensity);
	return Force;
}

float4 ComputeCollisionForce(const float3 Position)
{
	float3 CollisionForce = 0;
	for (uint i = 0; i < SpheresNumber; ++i)
	{
		FSphere Sphere = SphereBuffer[i];
		
		const float3 SpherePosition = Sphere.Center.xyz;
		const float Radius = Sphere.Radius;
		
		const float3 Direction = normalize(Position - SpherePosition);
		const float Distance = length(Position - SpherePosition);
		const bool bIsInside = Distance < Radius;
		
		CollisionForce += Direction * (Radius - Distance) * bIsInside;
	}
	
	float CollisionStrength = length(CollisionForce) + 0.001f; // Avoid division by zero
	float3 CollisionDirection = CollisionForce / CollisionStrength;
	
	return float4(CollisionDirection, CollisionStrength);
}

[numthreads(1024, 1, 1)]
void ComputePhysicsCS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
	if (DispatchThreadID.x >= GrassDataNumber)
		return;
	
	const FGrassData Data = Unpack(GrassDataBuffer[DispatchThreadID.x]);
	const float SpecWeight = .2f;
	const float Mass = SpecWeight * Data.Height * Data.Width * .05f; // Area of a triangle
	
	const float PreviousCollisionStrength = RWGrassForceMap[Data.Index].w;
	const float3 PreviousDisplacement = RWGrassForceMap[Data.Index].xyz;
	
	const float3 V2RestPosition = Data.Position + Data.Up * Data.Height;
	const float3 V2PreviousPosition = V2RestPosition + PreviousDisplacement;
	const float3 V0V2 = V2PreviousPosition - Data.Position;
	
	
	// Collision displacement
	const float4 CollisionForce = ComputeCollisionForce(V2PreviousPosition);
	// Fading over time of the collision strength
	const float CollisionStrength = max(PreviousCollisionStrength - FadingFactor * DeltaTime, 0) + CollisionForce.w;
	RWGrassForceMap[Data.Index].w = CollisionStrength;
	
	// 1. Recovery Force
	const float3 Recovery = (V2RestPosition - V2PreviousPosition) * Data.Stiffness * max(1 - CollisionStrength, 0.1f);

	// 2. Gravity Force
	const float3 GlobalGravity = Mass *
		(  GravityDirection.xyz * GravityDirection.w * (1 - bIsCenterOfGravityEnabled)
		 + normalize(GravityCenter.xyz - Data.Position) * GravityCenter.w * bIsCenterOfGravityEnabled);
	const float3 FrontGravity = length(GlobalGravity) * .25f * Data.Facing;
	const float3 Gravity = GlobalGravity + FrontGravity;

	// 3. Wind Force
	float4 WindForce = GetWindForce(Data.Position);
	
	const float DirectionalAlignment = 1 - abs(dot(WindForce.xyz, normalize(V0V2)));
	const float HeightRatio = dot(V0V2, Data.Up) / Data.Height;
	const float AlignmentValue = DirectionalAlignment * HeightRatio;
	const float3 Wind = WindForce.xyz * WindForce.w * AlignmentValue;

	// Resultant Force
	const float3 ResultForce = Gravity + Recovery + Wind;
	const float3 Displacement = ResultForce * DeltaTime + CollisionForce.xyz * CollisionStrength;
	
	RWGrassForceMap[Data.Index].xyz = Displacement;
}