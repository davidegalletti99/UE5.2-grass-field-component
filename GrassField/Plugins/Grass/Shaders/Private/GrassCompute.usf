#include "/Engine/Private/Common.ush"
#include "GrassUtil.ush"
#include "Noise.ush"

RWStructuredBuffer<uint> RWCounter;

uint GrassDataSize;
float4x4 VP_MATRIX;
float CutoffDistance;
float3 CameraPosition;
float Lambda;

// GrassDataBuffer
RWStructuredBuffer<PackedGrassData> RWGrassDataBuffer;
StructuredBuffer<PackedGrassData> GrassDataBuffer;

// CulledGrassDataBuffer
RWStructuredBuffer<PackedLodGrassData> RWCulledGrassDataBuffer;
StructuredBuffer<PackedLodGrassData> CulledGrassDataBuffer;

// Vertex Buffers
RWStructuredBuffer<GrassVertex> RWVertexBuffer;
StructuredBuffer<GrassVertex> VertexBuffer;

// IndexBuffer
RWStructuredBuffer<uint> RWIndexBuffer;
StructuredBuffer<uint> IndexBuffer;

// IndirectArgsBufferSRV
RWStructuredBuffer<uint> RWIndirectArgsBuffer;
RWStructuredBuffer<uint> IndirectArgsBufferSRV;

/**
 * Initialise the indirect args for the final culled indirect draw call.
 */
[numthreads(1, 1, 1)]
void InitIndirectArgsCS()
{
    RWIndirectArgsBuffer[0] = 0; // = NumIndices;
    RWIndirectArgsBuffer[1] = 1; // Increment this counter during ComputeGrassMeshCS.
    RWIndirectArgsBuffer[2] = 0;
    RWIndirectArgsBuffer[3] = 0;
    RWIndirectArgsBuffer[4] = 0;
}


/**
 * Compute shader to initialize all buffers.
 */
[numthreads(1, 1, 1)]
void InitBuffersCS()
{
    RWCounter[0] = 0;
    RWCounter[1] = 0;
    
	// CullInstances indirect args
    RWIndirectArgsBuffer[0] = 0; // Increment this wave counter during CullGrassDataCS.
    RWIndirectArgsBuffer[1] = 0;
    RWIndirectArgsBuffer[2] = 0;
    RWIndirectArgsBuffer[3] = 0; // Increment this instance counter counter during CullGrassDataCS.
}

/**
 * Cull the potentially visible render items for a view and generate the final buffer of instances to render.
 */

[numthreads(1024, 1, 1)]
void CullGrassDataCS(
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GropupId : SV_GroupID)
{
    uint GrassIndex = DispatchThreadId.x;
    if (GrassIndex >= GrassDataSize)
        return;
    
    PackedGrassData Data = GrassDataBuffer[GrassIndex];
    
    bool inView = IsInViewFrustum(Data.Position, VP_MATRIX, 0.2f);
    bool withinDistance = distance(CameraPosition.xyz, Data.Position) < CutoffDistance;
    
    if (inView && withinDistance)
    {
        PackedLodGrassData OutData;
        
        OutData.Position = Data.Position;
        OutData.LodLevel = computeLodSteps(uint2(0, 7), CutoffDistance, CameraPosition, OutData.Position);
        OutData.HeightAndWidth = Data.HeightAndWidth;
        OutData.Facing = Data.Facing;
        OutData.Hash = Data.Hash;
        uint WriteIndex;
        InterlockedAdd(RWCounter[0], 1, WriteIndex);
        RWCulledGrassDataBuffer[WriteIndex] = OutData;

    }
}

float3 rotateZ(float angle, float3 vec)
{
    float3x3 rot = float3x3(    cos(angle), -sin(angle),  0,
                                sin(angle),  cos(angle),  0,
                                         0,           0,  1);
    return mul(rot, vec);
}

void CreateGrassBlade(LodGrassData Data)
{
    
    uint LodSteps = Data.LodLevel;
    float3 p0 = Data.Position;
    float2 facing = Data.Facing;
    float height = Data.Height;
    float width = Data.Width;
    
    
    float3 v0 = computeInitialVelocity(float3(0, 0, 1), height);
    float te = v0.z / GRAVITATIONAL_ACCELERATION;
    
    
    uint VertexId, IndexId;
    InterlockedAdd(RWCounter[1], LodSteps * 2 + 1, VertexId);
    InterlockedAdd(RWIndirectArgsBuffer[0], (LodSteps * 2 - 1) * 3, IndexId);
    
    float3 CameraDistanceVector = normalize(p0 - CameraPosition);
    bool IsFront = dot(CameraDistanceVector.xy, facing) <= 0;
    
    float3 normal = float3(facing * (IsFront - 0.5) * 2, 0);
    float3 orto = -normalize(cross(float3(facing, 1), float3(facing, 0)));

    for (uint i = 0; i < LodSteps; i++, VertexId += 2, IndexId += 6)
    {
        float perc = float(i) / LodSteps;
        float t = perc * te;
        float3 p = movePoint(p0, v0, t);
        float thickness = quadBez(width, width * 0.85, 0, perc);
        
        GrassVertex p1, p2;
        
        
        // p1
        p1.Position = p - orto * thickness;
        p1.UV = float2(perc, 0);
        p1.Normal = rotateZ(PI * (-0.3), normal);
        addPoint(RWVertexBuffer, VertexId + 0, p1);
        
        // p2
        p2.Position = p + orto * thickness;
        p2.UV = float2(perc, 1);
        p2.Normal = rotateZ(PI * (0.3), normal);
        addPoint(RWVertexBuffer, VertexId + 1, p2);
        
        
        if (i < LodSteps - 1)
        {
            if (IsFront)
            {
                // t1
                addTri(RWIndexBuffer, IndexId + 0,
                    VertexId + 0, VertexId + 1, VertexId + 3);
                // t2
                addTri(RWIndexBuffer, IndexId + 3,
                    VertexId + 0, VertexId + 3, VertexId + 2);
            }
            else
            {
                // t1
                addTri(RWIndexBuffer, IndexId + 0,
                    VertexId + 0, VertexId + 3, VertexId + 1);
                // t2
                addTri(RWIndexBuffer, IndexId + 3,
                    VertexId + 0, VertexId + 2, VertexId + 3);
            }
        }
        else
        {
            
            if (IsFront)
            {
                // last triangle
                addTri(RWIndexBuffer, IndexId + 0,
                VertexId + 0, VertexId + 1, VertexId + 2);
            }
            else
            {
                // last triangle
                addTri(RWIndexBuffer, IndexId + 0,
                    VertexId + 0, VertexId + 2, VertexId + 1);
            }
        }
        
    }
    
    // last point
    GrassVertex pe;
    pe.Position = movePoint(p0, v0, te);
    pe.UV = float2(1, 1);
    pe.Normal = normal;
    
    addPoint(RWVertexBuffer, VertexId, pe);
}

[numthreads(1024, 1, 1)]
void ComputeGrassMeshCS(
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GropupId : SV_GroupID)
{
    uint GrassIndex = DispatchThreadId.x;
    if (GrassIndex >= RWCounter[0])
        return;

    LodGrassData Data = Unpack(CulledGrassDataBuffer[GrassIndex]);
    CreateGrassBlade(Data);
}