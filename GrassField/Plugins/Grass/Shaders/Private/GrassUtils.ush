#pragma once
// #include "Noise.ush"

#define GRAVITATIONAL_ACCELERATION 9.81
#define PI 3.14159265359
#define SQ_2_PI 2.50662827463
#define FORWARD_VECTOR float3(0, 1, 0)

// Calcola la curva di BÃ©zier quadratica
#define QUAD_BEZ(p0, p1, p2, t) (lerp(p0, lerp(p1, p2, t), t))
#define CUBIC_BEZ(p0, p1, p2, p3, t) (lerp(QUAD_BEZ(p0, p1, p2, t), QUAD_BEZ(p1, p2, p3, t), t))
#define GAUSSIAN_MAP(m, s, x) (exp(-(x - m)*(x - m) / (2 * s * s)) / (s * SQ_2_PI))

#define IDENTITY_MATRIX_3X3 float3x3( \
        float3(1, 0, 0), \
        float3(0, 1, 0), \
        float3(0, 0, 1))

#define IDENTITY_MATRIX_4X4 float4x4( \
        float4(1, 0, 0, 0), \
        float4(0, 1, 0, 0), \
        float4(0, 0, 1, 0), \
        float4(0, 0, 0, 1))

#define ROTATION_MATRIX_Z_3X3(angle) float3x3( \
        float3(cos(angle), -sin(angle), 0), \
        float3(sin(angle), cos(angle),  0), \
        float3(         0,          0,  1))

#define ROTATION_MATRIX_Z_4X4(angle) float4x4( \
        float4(cos(angle), -sin(angle), 0, 0), \
        float4(sin(angle),  cos(angle), 0, 0), \
        float4(         0,           0, 1, 0), \
        float4(         0,           0, 0, 1))


#define SKEW_SYMMETRIC_CROSS_PRODUCT_MATRIX_3X3(vec) float3x3( \
        float3(    0, -vec.z,  vec.y), \
        float3(vec.z,      0, -vec.x), \
        float3(vec.y,  vec.x,      0))

#define SKEW_SYMMETRIC_CROSS_PRODUCT_MATRIX_4X4(vec) float4x4( \
        float4(    0, -vec.z,  vec.y, 0), \
        float4(vec.z,      0, -vec.x, 0), \
        float4(vec.y,  vec.x,      0, 0), \
        float4(    0,      0,      0, 0))

#define TRANSLATION_MATRIX_4X4(vec) float4x4( \
        float4(1, 0, 0, vec.x), \
        float4(0, 1, 0, vec.y), \
        float4(0, 0, 1, vec.z), \
        float4(0, 0, 0,      1))

#define SCALE_MATRIX_4X4(vec) float4x4( \
        float4(vec.x,      0,      0, 0), \
        float4(     0, vec.y,      0, 0), \
        float4(     0,      0, vec.z, 0), \
        float4(     0,      0,      0, 1))
    


/** 
 * Struct per la generazione dei fili d'erba
 */
struct FGrassData
{
    float3 Position;
    float2 Facing;
	// float WindStrength;
    
    int Hash;
    
    float Height;
    float Width;
    
    // float Tilt;
    // float Bend;
};

struct FPackedGrassData
{
    float3 Position;
    uint Facing;
	// float WindStrength;

    int Hash;

    uint HeightAndWidth;
	// uint TiltAndBand;
};

struct FLodGrassData
{
    float3 Position;
    float2 Facing;
	// float WindStrength;
    
    int Hash;
    uint LodLevel;
    
    float Height;
    float Width;
    
    // float Tilt;
    // float Bend;
};

struct FPackedLodGrassData
{
    float3 Position;
    uint Facing;
	// float WindStrength;

    int Hash;
    uint LodLevel;

    uint HeightAndWidth;
	// uint TiltAndBand;
};

struct FGrassVertex
{
    float3 Position;
    float2 UV;
    
    float3 TangentX;
    float4 TangentZ; // TangentZ.w contains sign of tangent basis determinant
};

struct FGrassInstance
{
    float4x4 Transform;
    int Hash;
};

/*
 * Pack the GrassData into a PackedGrassData.
 * @param InData The raw data.
 * @return The packed data.
 */
FPackedGrassData Pack(const FGrassData InData)
{
    FPackedGrassData OutData;
    
    // prendo i 4 bit medno significativi dall'esponente e 12 dalla mantissa
    // 0    7    f    f    f    8    0    0
    // 0000 0111 1111 1111 1111 1000 0000 0000
    OutData.HeightAndWidth = (asuint(InData.Height) & 0x7fff8000) << 1;
    OutData.HeightAndWidth |= (asuint(InData.Width) & 0x7fff8000) >> 15;
    
    // prendo i 3 bit medno significativi dall'esponente e 13 dalla mantissa    
    // 0    3    f    f    f    a    0    0
    // 0000 0011 1111 1111 1111 1100 0000 0000
    uint Signes = (asuint(InData.Facing.x) & 0x80000000);
    Signes |= (asuint(InData.Facing.y) & 0x80000000) >> 16;
    
    OutData.Facing = (asuint(InData.Facing.x) & 0x3fff8000) << 1;
    OutData.Facing |= (asuint(InData.Facing.y) & 0x3fff8000) >> 15;
    OutData.Facing |= Signes;

    OutData.Position = InData.Position;
    OutData.Hash = InData.Hash;
    
    return OutData;
}

/*
 * Unpack the PackedGrassData into a LodGrassData.
 * @param InData The packed data.
 * @return The unpacked data.
 */
FGrassData Unpack(const FPackedGrassData InData)
{
    FGrassData OutData = (FGrassData) 0;
    
    OutData.Position = InData.Position;
    OutData.Hash = InData.Hash;
    
    OutData.Height = asfloat((InData.HeightAndWidth & 0xffff0000) >> 1);
    OutData.Width = asfloat((InData.HeightAndWidth & 0x0000ffff) << 15);
    
    const uint SignX = InData.Facing & 0x80000000;
    const uint SignY = (InData.Facing & 0x00008000) << 16;
    OutData.Facing.x = asfloat(SignX | (InData.Facing & 0x7fff0000) >> 1);
    OutData.Facing.y = asfloat(SignY | (InData.Facing & 0x00007fff) << 15);
    
    return OutData;
}

/*
 * Unpack the PackedLodGrassData into a LodGrassData.
 * @param InData The packed data.
 * @return The unpacked data.
 */
FLodGrassData Unpack(const FPackedLodGrassData InData)
{
    FLodGrassData OutData = (FLodGrassData) 0;
    
    OutData.Position = InData.Position;
    OutData.Hash = InData.Hash;
    OutData.LodLevel = InData.LodLevel;
    
    OutData.Height = asfloat((InData.HeightAndWidth & 0xffff0000) >> 1);
    OutData.Width = asfloat((InData.HeightAndWidth & 0x0000ffff) << 15);
    
    const uint SignX = InData.Facing & 0x80000000;
    const uint SignY = (InData.Facing & 0x00008000) << 16;
    OutData.Facing.x = asfloat(SignX | (InData.Facing & 0x7fff0000) >> 1);
    OutData.Facing.y = asfloat(SignY | (InData.Facing & 0x00007fff) << 15);
    
    return OutData;
}

/*
 * Unpack the Height and Width from the HeightAndWidth field of the packed data.
 * @param HeightAndWidth The HeightAndWidth field of the packed data.
 * @return float2(Height, Width)
 */
float2 UnpackHeightAndWidth(const uint HeightAndWidth)
{
    float2 HeightAndWidthF = 0;
    HeightAndWidthF.x = asfloat((HeightAndWidth & 0x0000ffff) << 15);
    HeightAndWidthF.y = asfloat((HeightAndWidth & 0xffff0000) >> 1);
    
    return HeightAndWidthF;
}

/*
 * Unpack the Facing from the Facing field of the packed data.
 * @param Facing The Facing field of the packed data.
 * @return the unpacked Facing.
 */
float2 UnpackFacing(const uint Facing)
{
    float2 FacingF = 0;
    
    const uint SignX = Facing & 0x80000000;
    const uint SignY = (Facing & 0x00008000) << 16;
    FacingF.x = asfloat(SignX | (Facing & 0x7fff0000) >> 1);
    FacingF.y = asfloat(SignY | (Facing & 0x00007fff) << 15);
    
    return FacingF;
}

/*
uint ComputeVertexBufferSize(const uint NumLod)
{
    // Sum(i : 0 -> NumLod) (( i + 1 ) * 2 + 1)
    return (NumLod + 3) * (NumLod + 1);
}
uint ComputeIndexBufferSize(const uint NumLod)
{
    // Sum(i : 0 -> NumLod) ( i * 2 + 1) * 6
    return (NumLod + 1) * (NumLod + 1) * 2 * 3;
}

uint ComputeVertexBufferOffset(const uint NumLod)
{
    return NumLod * (NumLod + 2);
}

uint ComputeIndexBufferOffset(const uint NumLod)
{
    return (NumLod * NumLod) * 2 * 3;
}
*/

float3 RotateZ(const float Angle, const float3 Vec)
{
    const float3x3 Rot = ROTATION_MATRIX_Z_3X3(Angle);
    return mul(Rot, Vec);
}

float4x4 ComputeA2BRotationMatrix(float3 A, float3 B)
{
    const float Sine = length(cross(A, B));
    const float Cosine = dot(A, B);

    const float3x3 SkewMat = SKEW_SYMMETRIC_CROSS_PRODUCT_MATRIX_3X3(A);
    
    const float3x3 IdentityMat = IDENTITY_MATRIX_3X3;
    const float3x3 RotationMat =  IdentityMat + SkewMat + mul(SkewMat, SkewMat) * ((1 - Cosine) / (Sine * Sine));
    
    return float4x4(
            float4(RotationMat[0], 0),
            float4(RotationMat[1], 0),
            float4(RotationMat[2], 0),
            float4(0, 0, 0, 1));
}

float4x4 ComputeTransformRotationMatrix(FGrassData Data)
{
    float CosAngle = dot(Data.Facing, FORWARD_VECTOR.xy);
    float SinAngle =  sqrt(1 - CosAngle * CosAngle);
    
    float4x4 RotationMatrix = float4x4(
            float4(CosAngle, -SinAngle, 0, 0),
            float4(SinAngle,  CosAngle, 0, 0),
            float4(       0,         0, 1, 0),
            float4(       0,         0, 0, 1)
    );
    return RotationMatrix; // ComputeA2BRotationMatrix(-FORWARD_VECTOR, float3(InstanceData.Facing, 0));
}

float4x4 ComputeTransformMatrixNoScale(FGrassData Data)
{
    const float4x4 RotationMatrix = ComputeTransformRotationMatrix(Data);
    const float4x4 TranslationMatrix = TRANSLATION_MATRIX_4X4(Data.Position);
    
    return mul(TranslationMatrix, RotationMatrix);
}

float4x4 ComputeTransformMatrix(FGrassData Data)
{
    const float4x4 ScaleMatrix = SCALE_MATRIX_4X4(float3(Data.Width, Data.Width, Data.Height));
    const float4x4 RotationMatrix = ComputeTransformRotationMatrix(Data);
    const float4x4 TranslationMatrix = TRANSLATION_MATRIX_4X4(Data.Position);

    const float4x4 ScaleAndRotation = mul(RotationMatrix, ScaleMatrix);
    const float4x4 Result = mul(TranslationMatrix, ScaleAndRotation);
    
    return Result;
}

void ComputeFrustumPlanes(
        const float4x4 ViewProjectionMatrix,
        inout float4 Planes[6])
{
    Planes[0] = ViewProjectionMatrix[3] + ViewProjectionMatrix[0];
    Planes[1] = ViewProjectionMatrix[3] - ViewProjectionMatrix[0];
    Planes[2] = ViewProjectionMatrix[3] + ViewProjectionMatrix[1];
    Planes[3] = ViewProjectionMatrix[3] - ViewProjectionMatrix[1];
    Planes[4] = ViewProjectionMatrix[3] + ViewProjectionMatrix[2];
    Planes[5] = ViewProjectionMatrix[3] - ViewProjectionMatrix[2];
}

/** Return false if the AABB is completely outside one of the planes. */
bool PlaneTestAABB(in float4 InPlanes[5], in const float3 InCenter, in const float3 InExtent)
{
    bool bPlaneTest = true;
	
	[unroll]
    for (uint PlaneIndex = 0; PlaneIndex < 5; ++PlaneIndex)
    {
        float3 PlaneSigns;
        PlaneSigns.x = InPlanes[PlaneIndex].x >= 0.f ? 1.f : -1.f;
        PlaneSigns.y = InPlanes[PlaneIndex].y >= 0.f ? 1.f : -1.f;
        PlaneSigns.z = InPlanes[PlaneIndex].z >= 0.f ? 1.f : -1.f;

        const bool bInsidePlane = dot(InPlanes[PlaneIndex], float4(InCenter + InExtent * PlaneSigns, 1.0f)) > 0.f;
        bPlaneTest = bPlaneTest && bInsidePlane;
    }

    return bPlaneTest;
}

bool IsInViewFrustum(in const float3 Position, in const float4x4 ViewProjectionMatrix, in const float Margin)
{
    const float4 Position4 = float4(Position, 1.0f);
    const float4 ViewSpace = mul(Position4, ViewProjectionMatrix);
    
    float3 ClipSpace = ViewSpace.xyz;
    ClipSpace /= ViewSpace.w;

    ClipSpace.xy = ClipSpace.xy / 2.0f + 0.5f;
    
    return ClipSpace.x >= 0.0f - Margin && ClipSpace.x <= 1.0f + Margin
        && ClipSpace.y >= 0.0f - Margin && ClipSpace.y <= 1.0f + Margin
        && ClipSpace.z >= 0.0f && ClipSpace.z <= 1.0f;
}

/**
 * Aggiunge il vertice @data al buffer @VertexBuffer 
 * in posizione @vertexPos
 */ 
void AddPoint(
    in RWStructuredBuffer<FGrassVertex> VertexBuffer,
    in const uint VertexPos, in const FGrassVertex Data)
{
    VertexBuffer[VertexPos] = Data;
}

/**
 * Aggiunge il triangolo definiito dagli indici @idx1, @idx2 e @idx3 
 * al buffer @IndexBuffer partendo dalla posizione @indexPos
 */
void AddTri(
    in RWStructuredBuffer<uint> IndexBuffer, 
    in const uint IndexPos, in const uint Idx1, in const uint Idx2, in uint Idx3)
{
    IndexBuffer[IndexPos + 0] = Idx1;
    IndexBuffer[IndexPos + 1] = Idx2;
    IndexBuffer[IndexPos + 2] = Idx3;
}

//  z
//  |
//  |
//  |         * *         -
//  |    y  *     *       |
//  |   /  *              | height
//  |  /  *               |
//  | /  *                |
//  |/   *                -
//  +-------------------------- x
//  0
float3 ComputeInitialVelocity(in const float3 Seed, in const float Height)
{
    float3 V0 = Seed;
    V0.xy += sign(V0.xy) * 1.5;
    V0.z = sqrt(2 * GRAVITATIONAL_ACCELERATION * Height);
    return V0;
}

uint ComputeLodSteps(const uint2 MinMaxLod, const float CutoffDistance, const float3 CameraPosition, const float3 PointPosition)
{
    const float Dist = distance(CameraPosition, PointPosition);
    return ceil(lerp(MinMaxLod.x, MinMaxLod.y, GAUSSIAN_MAP(0, 0.4f, 2 * Dist / CutoffDistance)));
}

float3 MovePoint(const float3 Pi, const float3 Vi, const float T)
{
    float3 P = Pi + Vi * T;
    P.z -= T * T * GRAVITATIONAL_ACCELERATION / 2;
    return P;
}