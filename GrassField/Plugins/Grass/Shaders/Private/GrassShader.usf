#include "/Engine/Public/Platform.ush"
#include "GrassData.ush"
#include "Noise.ush"

#define G 9.81
#define PI 3.141
#define invTanMap(x) (2 * atan(x) / PI)

float Lambda;

RWStructuredBuffer<uint> ArgsBuffer;
RWStructuredBuffer<GrassData> GrassDataBuffer;

RWStructuredBuffer<float3> GrassPoints;
RWStructuredBuffer<int> GrassTriangles;

static int maxSteps = 7;
static int minSteps = 7;

// Aggiunge il punto @p al buffer GrassPoints 
// in posizione @pointIdx
void addPoint(in uint pointIdx, in float3 p)
{
    GrassPoints[pointIdx] = p;
    
    // solo per debug (da modificare)
    InterlockedAdd(ArgsBuffer[2], 1);
}


// Aggiunge il triangolo definiito dagli indici @idx1, @idx2 e @idx3 
// al buffer GrassTriangles in partendo dalla posizione @triIdx
void addTri(in uint triIdx, in uint idx1, in uint idx2, in uint idx3)
{
    GrassTriangles[triIdx + 0] = idx1;
    GrassTriangles[triIdx + 1] = idx2;
    GrassTriangles[triIdx + 2] = idx3;
    
    // solo per debug (da modificare)
    InterlockedAdd(ArgsBuffer[3], 3);
}

// Calcola la curva di Bézier quadratica
float3 quadBez(in float p0, in float p1, in float p2, in float t)
{
    return lerp(p0, lerp(p1, p2, t), t);
}


//  z
//  |
//  |
//  |         * *         -
//  |    y  *     *       |
//  |   /  *              | height
//  |  /  *               |
//  | /  *                |
//  |/   *                -
//  +-------------------------- x
//  0
float3 computeInitialVelocity(in float3 seed, in float height)
{
    float3 v0 = seed;
    v0.xy += sign(v0.xy) * 1.5;
    v0.z = sqrt(2 * G * height);
    return v0;
}

float3 movePoint(in float3 pi, in float3 vi, in float t)
{
    float3 p = pi + vi * t;
    p.z -= t * t * G / 2;
    return p;
}

//  z
//  |
//  |
//  |         * *
//  |    y  *     * pe (t = te)
//  |   /  *    
//  |  /  *
//  | /  *
//  |/   * p0 (t = 0)
//  +-------------------------- x
//  0
void createGrass(in uint idx, in float3 p0, in float height, in int steps)
{
    // initial condictions
    float3 ext = rand3(p0);
    
    float3 v0 = computeInitialVelocity(ext, height);
    float epsilon = (snoise(p0 / 1000) - 0.5f) * Lambda;
    float te = (v0.z - epsilon) / G;
    
    float maxThickness = height * 0.02;
    float3 normal = normalize(cross(v0, float3(v0.xy, 0)));
    
    uint pointIdx = idx * (steps * 2 + 1);
    uint triangleIdx = idx * (steps * 2 - 1) * 2; // '* 2' per i triangoli dietro
    
    uint grassPIdx = pointIdx;
    uint grassTIdx = triangleIdx * 3;
    for (uint i = 0; i < steps; i++, grassTIdx += 12, grassPIdx += 2)
    {
        float perc = float(i) / steps;
        float t = perc * te;
        
        float3 p = movePoint(p0, v0, t);
        float thickness = quadBez(maxThickness, maxThickness * 0.85, 0, perc);
        
        // p1
        float3 p1 = p - normal * thickness;
        addPoint(grassPIdx + 0, p1);
        
        // p2
        float3 p2 = p + normal * thickness;
        addPoint(grassPIdx + 1, p2);
        
        
        if (i < steps - 1)
        {
            // t1
            addTri(grassTIdx + 0, grassPIdx + 0, grassPIdx + 1, grassPIdx + 3); // front
            addTri(grassTIdx + 3, grassPIdx + 0, grassPIdx + 3, grassPIdx + 1); // back
                
            // t2
            addTri(grassTIdx + 6, grassPIdx + 0, grassPIdx + 3, grassPIdx + 2); // front
            addTri(grassTIdx + 9, grassPIdx + 0, grassPIdx + 2, grassPIdx + 3); // back
        }
        else
        {
            // last triangle
            addTri(grassTIdx + 0, grassPIdx + 0, grassPIdx + 1, grassPIdx + 2); // front
            addTri(grassTIdx + 3, grassPIdx + 0, grassPIdx + 2, grassPIdx + 1); // back
        }
        
    }
    
    // last point
    float3 pe = movePoint(p0, v0, te);
    addPoint(grassPIdx, pe);
}


[numthreads(1024, 1, 1)]
void Main(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 GroupId : SV_GroupID,
	uint GroupIndex : SV_GroupIndex)
{
    uint id = DispatchThreadId.x;
    if (id >= ArgsBuffer[1])
        return;
    
    float3 p0 = GrassDataBuffer[id].position;
    float height = GrassDataBuffer[id].height;
    createGrass(id, p0, height, 7);
}